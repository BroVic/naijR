---
title: "nigeria-maps"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nigeria-maps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(naijR)
```
The need for relatively easy-to-use tools for mapping data on Nigeria was one of the motivations behind the development of this package. Not so much of low-level programming was done; rather a collection of pre-existing packages and idioms from the R ecosystem were employed and brought together to enable the user focus more on the actual visualization of data on the country map instead of the programming.

The key function for drawing Nigeria maps is called `map_ng()`. This uses data from the CIA World Database provided by the `mapdata` package to draw a simple map of Nigeria showing state boundaries.

```{r original-map}
map_ng()
```

To show a simple outline map without the state borders, set the `region` argument to `NULL`. Thus with all other arguments set to default values, that would be

```{r outline-map}
map_ng(NULL)
```

## Choropleth maps
Choropleth maps, to display regional differences can also be created with `map_ng()`. There are a number of ways through which this can be done,depending on the kind of arguments supplied to the function:

- A data frame containing a column for the regions and at least one other for the data to be displayed, or
- A vector for the regions and another for the data to be displayed.

This map is built on categorical data (i.e. `factor`s) and atomic vectors that are coercible to this class are accepted. In the case of numeric data, notable those of type `double`, they can be coaxed into categories if class boundaries are provided via the `breaks` argument.

To demonstrate this feature, we will create a data frame with fake data:
```{r dud-dataframe}
ss <- states()
numStates <- length(ss)
vv <- sample(LETTERS[1:5], numStates, TRUE)
dd <-
  data.frame(
    state = ss,
    var = vv,
    stringsAsFactors = FALSE
  )
head(dd)
```

### Using a data frame
To draw this choropleth, we will use the data frame approach first:
```{r df-approach}
map_ng(data = dd, x = var)
```

Note the following:

- The argument `var` is the name of the chosen column of our data frame and is found using quasiquotation. To explore this further see `?rlang::quasiquotation`.
- The colours darken sequentially from A through E. This follows the natural (alphabetical) ordering of the level of the factor. To determine this order upfront, create an __ordered factor__ through in any the various ways available in R. (See below for example)
- Our variable `var` is actually a character vector, but internally is converted to a factor.

The flavour of geo-spatial data used in the package is of the vector type--and of these, it uses *point* and *polygon* data (incorporation of *line* layers is planned for a future release).

### Using vectors
We can use the same data to make the same map, but with a different coding approach:
```{r vec-approach}
map_ng()
```

## Plain maps
```{r}

```

## Plain maps with boundaries
## Choropleth maps